---
title: æ’åºç®—æ³•æ€»ç»“
author: Falldio
date: 2023-3-6
layout: blog
location: æ­¦æ±‰
tags:
    - ç®—æ³•
    - CPP
    - Go
summary: å¸¸ç”¨æ’åºç®—æ³•å½’çº³æ€»ç»“å’ŒGolangå®ç°ï¼Œé™„å¸¦Golangå’ŒCPPä¸­sortç®—æ³•æºç åˆ†æã€‚
---

æœ€è¿‘åœ¨LeetCode Daily Challengeä¸­ç¢°åˆ°ä¸€é“æœ´å®æ— åçš„[æ’åºç®—æ³•é¢˜](https://leetcode.com/problems/sort-an-array/)ï¼Œä½ åªéœ€è¦æƒ³åŠæ³•åœ¨$O(nlog(n))$å†…æ’åºä¸€ä¸ªæ•´å‹æ•°ç»„å°±å¯ä»¥äº†ï¼Œæ¯”å¦‚ç”¨å½’å¹¶æ’åºã€å †æ’åºç­‰ã€‚æˆ‘è§‰å¾—å€¼å¾—ä¸€å†™çš„åŸå› æ˜¯ï¼Œæˆ‘ç¼ºå°‘å¯¹å„ç§æ’åºç®—æ³•çš„æ•´ç†ï¼Œä¹Ÿæ²¡æœ‰ä»”ç»†çœ‹è¿‡Golangä¸­çš„æ’åºç®—æ³•æºç å®ç°ï¼Œè¿™ç¯‡blogè¡¥å…¨äº†è¿™ä¸ªç¼ºæ†¾ã€‚

## æ’åºç®—æ³•æ€»ç»“
### é€‰æ‹©æ’åº

+ æ‰¾åˆ°å½“å‰æ•°ç»„**æœªå¤„ç†éƒ¨åˆ†**ä¸­æœ€å°çš„å…ƒç´ ï¼Œå’Œæ•°ç»„ä¸­ç¬¬`i`ä¸ªå…ƒç´ äº¤æ¢ä½ç½®ï¼Œç›´åˆ°æ•´ä¸ªæ•°ç»„æ’åºå®Œæˆã€‚

è¿™å…¶å®ç®—æ˜¯ä¸€ç§æš´åŠ›è§£æ³•ï¼Œå³æ¯æ¬¡æ‹¿å‡ºæœ€å°å…ƒç´ æ”¾åˆ°ç»“æœæ•°ç»„é‡Œï¼ˆåªæ˜¯ä¸ç”¨å¦å¤–å¼€è¾Ÿå†…å­˜ç©ºé—´è€Œå·²ï¼‰ï¼Œå…¶æ—¶é—´å¤æ‚åº¦ä¸º$O(n^2)$ï¼Œå› ä¸ºæ¯æ¬¡æ‰¾æœ€å°å…ƒç´ çš„æ—¶é—´ï¼ˆworst caseï¼‰éƒ½ä¸æ•°ç»„é•¿åº¦æœ‰å…³ã€‚

é€ æˆç®—æ³•ä½æ•ˆçš„åŸå› æ˜¯ï¼šæ¯æ¬¡æ‰«æå¹¶ä¸èƒ½ç»™ä¸‹æ¬¡æ‰«ææä¾›ä»»ä½•ä¿¡æ¯ï¼Œå› æ­¤æ¯æ¬¡æ‰«æéƒ½éœ€è¦ä»å¤´å¼€å§‹ã€‚å¦å¤–ï¼Œç®—æ³•è¿è¡Œæ—¶é—´ä¸æ•°ç»„ä¸­å…ƒç´ çš„åˆå§‹é¡ºåºæ— å…³ï¼Œå³ä½¿ç»™å‡ºä¸€ä¸ªæœ‰åºæ•°ç»„ï¼Œç®—æ³•ä»ç„¶éœ€è¦è¿›è¡Œnæ¬¡æ‰«æï¼ˆå½“ç„¶ï¼Œæœ€åä¸€æ¬¡åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œç›¸å½“äºå¯ä»¥çœä¸‹ä¸€æ¬¡æ‰«æï¼‰ã€‚

```go
func sort(nums []int) {
    for i := 0; i < len(nums); i++ {
        min := i
        for j := i + 1; j < len(nums); j++ {
            if nums[j] < nums[min] {
                min = j
            }
        }
        nums[min], nums[i] = nums[i], nums[min]
    }
}
```

### æ’å…¥æ’åº

+ éå†æ•°ç»„å…ƒç´ ï¼Œå°†å½“å‰å…ƒç´ æ’å…¥åˆ°**å·²æ’åºéƒ¨åˆ†**çš„åˆé€‚ä½ç½®ï¼Œç›´åˆ°æ•´ä¸ªæ•°ç»„æ’åºå®Œæˆã€‚

æ—¶é—´å¤æ‚åº¦ä¸º$O(n^2)$ï¼Œä¸€æ–¹é¢éå†æ•°ç»„éœ€è¦$O(n)$ï¼Œå¦ä¸€æ–¹é¢æ¯æ¬¡æ’å…¥å…ƒç´ éœ€è¦éå†å·²æ’åºéƒ¨åˆ†ï¼ŒåŒæ ·éœ€è¦$O(n)$ã€‚ä½†ç›¸æ¯”äºé€‰æ‹©æ’åºï¼Œæ’å…¥æ’åºåˆ©ç”¨äº†å·²æ’åºéƒ¨åˆ†çš„ä¿¡æ¯ï¼Œåœ¨æ•°ç»„åŸºæœ¬æœ‰åºçš„æƒ…å†µä¸‹ï¼Œä¸éœ€è¦åƒé€‰æ‹©æ’åºé‚£æ ·è¿›è¡Œé‡å¤æ‰«æã€‚**æ’å…¥æ’åº**å¯¹äºå°è§„æ¨¡æ•°ç»„çš„æ’åºæ•ˆç‡å¾ˆé«˜ï¼Œå› ä¸ºå®ƒçš„æ—¶é—´å¤æ‚åº¦æ¥è¿‘äº$O(n)$ã€‚

```go
// ç”¨äº¤æ¢çš„æ–¹å¼å®ç°æ’å…¥æ’åº
func sort(nums []int) {
    for i := 1; i < len(nums); i++ {
        for j := i; j > 0 && nums[j] < nums[j-1]; j-- {
            nums[j], nums[j-1] = nums[j-1], nums[j]
        }
    }
}

// ç”¨å³ç§»çš„æ–¹å¼å®ç°æ’å…¥æ’åº
func sort(nums []int) {
    for i := 1; i < len(nums); i++ {
        e := nums[i]
        j := i
        for ; j > 0 && nums[j-1] > e; j-- {
            // å°†å¤§äºeçš„å…ƒç´ å³ç§»
            nums[j] = nums[j-1]
        }
        nums[j] = e
    }
}
```

### å¸Œå°”æ’åº

+ å°†æ•°ç»„åˆ†ä¸º`h`ä¸ªå­æ•°ç»„ï¼Œå¯¹æ¯ä¸ªå­æ•°ç»„è¿›è¡Œ**æ’å…¥æ’åº**ï¼ˆè¿™äº›å­æ•°ç»„çš„å…ƒç´ äº¤ç»‡åœ¨ä¸€èµ·ï¼ŒåŒä¸€ä¸ªå­æ•°ç»„çš„å…ƒç´ ä½ç½®ç›¸å·®`h`ï¼‰ã€‚
+ é‡å¤ä¸Šè¿°è¿‡ç¨‹ï¼Œ`h`ä¸æ–­å‡å°ï¼Œç›´åˆ°`h=1`ï¼Œæ­¤æ—¶æ•°ç»„å·²ç»åŸºæœ¬æœ‰åºã€‚

å½“æ•°ç»„ç›¸å¯¹æœ‰åºçš„æ—¶å€™ï¼Œ**æ’å…¥æ’åº**çš„æ•ˆç‡ä¼šå¾ˆé«˜ï¼Œè€Œ**å¸Œå°”æ’åº**æƒè¡¡äº†å­æ•°ç»„çš„è§„æ¨¡å’Œæœ‰åºæ€§ã€‚å¯¹è§„æ¨¡è¾ƒå°çš„å­æ•°ç»„è¿›è¡Œ**æ’å…¥æ’åº**ï¼Œæ—¶é—´å¼€é”€è¾ƒå°ï¼Œè€Œæ’åºå­æ•°ç»„ä¹‹åï¼Œæ•°ç»„çš„å±€éƒ¨æœ‰åºæ€§ä¼šæé«˜ï¼Œè¿™æ ·å°±å¯ä»¥è¿›ä¸€æ­¥å‡å°‘**æ’å…¥æ’åº**çš„æ—¶é—´å¼€é”€ã€‚

å¸Œå°”æ’åºçš„æ—¶é—´å¤æ‚åº¦å’Œ`h`çš„é€‰æ‹©æœ‰å…³ï¼Œå¦‚æœ`h`çš„é€‰æ‹©ä¸å½“ï¼Œå¸Œå°”æ’åºçš„æ—¶é—´å¤æ‚åº¦å¯èƒ½ä¼šé€€åŒ–åˆ°$O(n^2)$ã€‚ä½†æ˜¯ï¼Œå¦‚æœ`h`çš„é€‰æ‹©åˆç†ï¼Œ**å¸Œå°”æ’åºçš„æ—¶é—´å¤æ‚åº¦å¯ä»¥è¾¾åˆ°$O(nlog(n))$**ã€‚

```go
func sort(nums []int) {
    // hçš„é€‰æ‹©å¯ä»¥å˜åŒ–
    h := 1
    for h < len(nums)/3 {
        h = 3*h + 1
    }

    for h >= 1 {
        for i := h; i < len(nums); i++ {
            e := nums[i]
            j := i
            // å¯¹hä¸ªå­æ•°ç»„åˆ†åˆ«è¿›è¡Œæ’å…¥æ’åºï¼Œè¿™é‡Œä½¿ç”¨å³ç§»æ³•
            for ; j >= h && nums[j-h] > e; j -= h {
                nums[j] = nums[j-h]
            }
            nums[j] = e
        }
        h /= 3
    }
}
```

### å½’å¹¶æ’åº

+ é€’å½’åœ°å°†æ•°ç»„åˆ†ä¸ºä¸¤ä¸ªå­æ•°ç»„ï¼Œåˆ†åˆ«å¯¹ä¸¤ä¸ªå­æ•°ç»„è¿›è¡Œ**å½’å¹¶æ’åº**ã€‚
+ å½“**å­æ•°ç»„é•¿åº¦ä¸º1**æ—¶ï¼Œè®¤ä¸ºè¯¥å­æ•°ç»„å·²ç»æœ‰åºï¼Œç›´æ¥è¿”å›ã€‚
+ åˆå¹¶å­æ•°ç»„ï¼Œåˆ©ç”¨ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘ä¸¤ä¸ªå­æ•°ç»„çš„å¤´éƒ¨ï¼Œæ¯”è¾ƒä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘çš„å…ƒç´ ï¼Œå°†**è¾ƒå°çš„å…ƒç´ **æ”¾å…¥ç»“æœæ•°ç»„ä¸­ï¼Œç›´åˆ°å…¶ä¸­ä¸€ä¸ªå­æ•°ç»„éå†å®Œæ¯•ï¼Œå°†å¦ä¸€ä¸ªå­æ•°ç»„å‰©ä½™çš„å…ƒç´ æ”¾å…¥ç»“æœæ•°ç»„ä¸­ã€‚

**å½’å¹¶æ’åº**çš„èƒŒåæ˜¯**Divide and Conquer**çš„æ€æƒ³ï¼Œå³å°†ä¸€ä¸ªå¤§é—®é¢˜åˆ†è§£ä¸ºè‹¥å¹²ä¸ªå°é—®é¢˜ï¼Œåˆ†åˆ«è§£å†³ï¼Œæœ€åå°†ç»“æœåˆå¹¶èµ·æ¥ã€‚**å½’å¹¶æ’åº**çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(nlog(n))$ï¼Œä½†æ˜¯è‡ªåº•è€Œä¸Šçš„**å½’å¹¶æ’åº**çš„ä»£ç é‡æ›´å°ã€‚å…³äºæ—¶é—´å¤æ‚åº¦çš„è®¨è®ºå¯ä»¥å‚è€ƒè¿™æœ¬ä¹¦[^1]ã€‚ç„¶è€Œï¼Œ**å½’å¹¶æ’åº**çš„ç©ºé—´å¤æ‚åº¦ä¸º$O(n)$ï¼Œå› ä¸ºéœ€è¦é¢å¤–çš„ç©ºé—´å­˜å‚¨å½’å¹¶ç»“æœï¼Œè§ä¸‹é¢ä»£ç å—ä¸­å¯¹`aux`æ•°ç»„çš„è®¨è®ºã€‚

[^1]: [ã€Šç®—æ³•ï¼ˆç¬¬4ç‰ˆï¼‰ã€‹](https://book.douban.com/subject/19952400/)

```go
// ä¸‹é¢çš„ä»£ç ç‰‡æ®µå°†auxä½œä¸ºmergeå‡½æ•°çš„å±€éƒ¨å˜é‡ï¼Œä½†æ˜¯è¿™å¹¶ä¸æ˜¯æœ€å¥½çš„å®ç°ï¼Œå› ä¸ºç®—æ³•åœ¨æ¯æ¬¡ä½¿ç”¨mergeå‡½æ•°æ—¶éƒ½éœ€è¦åå¤ç”³è¯·å’Œé‡Šæ”¾å†…å­˜ï¼Œæ›´å¥½çš„æ–¹æ³•æ˜¯å°†auxä½œä¸ºmergeå‡½æ•°çš„å‚æ•°ä¼ å…¥ã€‚

// è‡ªé¡¶è€Œä¸‹çš„å½’å¹¶æ’åº: é€’å½’åˆ†è§£æ•°ç»„ï¼Œç„¶ååˆå¹¶å­æ•°ç»„
func sort(nums []int) {
    divide(nums, 0, len(nums))
}

func divide(nums []int, left, right int) {
    if right-left <= 1 {
        // å­æ•°ç»„é•¿åº¦ä¸º1ï¼Œè®¤ä¸ºè¯¥å­æ•°ç»„å·²ç»æœ‰åº
        return
    }
    mid := left + (right - left) / 2
    divide(nums, left, mid)
    divide(nums, mid, right)
    merge(nums, left, mid, right)
}

func merge(nums []int, left, mid, right int) {
    // å°†æ’åºç»“æœæ”¾å…¥auxæ•°ç»„ä¸­æš‚å­˜ï¼Œæœ€åå¤åˆ¶åˆ°åŸæ•°ç»„
    aux := make([]int, right-left)
    i, j, k := left, mid, 0
    for i < mid && j < right {
        if nums[i] < nums[j] {
            aux[k] = nums[i]
            i++
        } else {
            aux[k] = nums[j]
            j++
        }
        k++
    }
    for i < mid {
        aux[k] = nums[i]
        i++
        k++
    }
    for j < right {
        aux[k] = nums[j]
        j++
        k++
    }
    copy(nums[left:right], aux)
}

// è‡ªåº•è€Œä¸Šçš„å½’å¹¶æ’åºï¼šå…ˆå¯¹å°æ•°ç»„è¿›è¡Œæ’åºï¼Œç„¶åä¸¤ä¸¤åˆå¹¶ï¼Œå†å¯¹å¤§æ•°ç»„è¿›è¡Œæ’åº
func sort(nums []int) {
    for sz := 1; sz < len(nums); sz *= 2 {
        for left := 0; left < len(nums)-sz; left += 2*sz {
            // åˆå¹¶ä¸¤ä¸ªå­æ•°ç»„, mergeå‡½æ•°åŒä¸Š
            merge(nums, left, left+sz, min(left+2*sz, len(nums)))
        }
    }
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

### å¿«é€Ÿæ’åº

+ **éšæœº**ä»æ•°ç»„ä¸­é€‰æ‹©ä¸€ä¸ªå…ƒç´ ä½œä¸ºåˆ‡åˆ†ã€‚
+ å°†æ•°ç»„åˆ†ä¸ºä¸¤ä¸ªå­æ•°ç»„ï¼Œå·¦å­æ•°ç»„çš„å…ƒç´ éƒ½å°äºåˆ‡åˆ†å…ƒç´ ï¼Œå³å­æ•°ç»„çš„å…ƒç´ éƒ½å¤§äºåˆ‡åˆ†å…ƒç´ ã€‚
+ åœ¨å­æ•°ç»„ä¸­é€’å½’åœ°è¿›è¡Œ**å¿«é€Ÿæ’åº**ã€‚

**å¿«é€Ÿæ’åº**åŒæ ·é‡‡ç”¨åˆ†æ²»æ€æƒ³ï¼Œåœ¨æ¯ä¸€æ¬¡åˆ‡åˆ†çš„è¿‡ç¨‹ä¹‹ä¸­ï¼Œå¿…ç„¶ä¼šç¡®å®šåˆ‡åˆ†å…ƒç´ åœ¨æœ‰åºæ•°ç»„ä¸­çš„ä½ç½®ã€‚æ­¤å¤–ï¼Œå¿«æ’çš„åˆ‡åˆ†è¿‡ç¨‹æ˜¯åŸåœ°çš„ï¼Œä¸éœ€è¦é¢å¤–çš„ç©ºé—´ã€‚åè§‚**å½’å¹¶æ’åº**ï¼Œæ¯æ¬¡åˆå¹¶éƒ½éœ€è¦é¢å¤–çš„ç©ºé—´æ¥æš‚å­˜åˆå¹¶ç»“æœã€‚å¿«æ’çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(nlog(n))$ï¼Œä¸”ä¸éœ€è¦é¢å¤–çš„ç©ºé—´å¼€é”€ã€‚

```go
func sort(nums []int) {
    // æ‰“ä¹±æ•°ç»„
    rand.Seed(time.Now().UnixNano())
    rand.Shuffle(len(nums), func(i, j int) {
        nums[i], nums[j] = nums[j], nums[i]
    })
    divide(nums, 0, len(nums))
}

func divide(nums []int, left, right int) {
    if right-left <= 1 {
        return
    }
    // åˆ‡åˆ†ï¼Œç”±äºæ•°ç»„å·²ç»æ‰“ä¹±ï¼Œå› æ­¤å¯ä»¥ä¿è¯åˆ‡åˆ†å…ƒç´ æ˜¯éšæœºé€‰æ‹©çš„
    j := partition(nums, left, right)
    divide(nums, left, j)
    divide(nums, j+1, right)
}

func partition(nums []int, left, right int) int {
    i, j := left+1, right-1
    mid := nums[left]
    for {
        // åœ¨å·¦å³æ•°ç»„ä¸­åˆ†åˆ«æ‰¾åˆ°ä¸ç¬¦åˆæ¡ä»¶çš„å…ƒç´ ï¼Œå¹¶è¿›è¡Œäº¤æ¢
        for i < right && nums[i] < mid {
            i++
        }
        for j > left && nums[j] > mid {
            j--
        }
        if i >= j {
            break
        }
        nums[i], nums[j] = nums[j], nums[i]
        i++
        j--
    }
    // å°†åˆ‡åˆ†å…ƒç´ æ”¾åˆ°æ­£ç¡®çš„ä½ç½®
    nums[left], nums[j] = nums[j], nums[left]
    return j
}
```

::: tip
å½“åˆ‡åˆ†å…ƒç´ æ˜¯æ•°ç»„ä¸­çš„æœ€å¤§æˆ–æœ€å°å…ƒç´ æ—¶ï¼Œå¿«æ’çš„æ—¶é—´å¤æ‚åº¦é€€åŒ–ä¸º$O(n^2)$ã€‚åœ¨åˆ‡åˆ†ä¹‹å‰å…ˆå°†æ•°ç»„æ‰“ä¹±å¯ä»¥å°½é‡é¿å…è¿™ç§æƒ…å†µã€‚

ä¹Ÿæœ‰ä¸€äº›é’ˆå¯¹å¿«æ’çš„æ”¹è¿›ç®—æ³•ï¼Œæ¯”å¦‚åœ¨å°æ•°ç»„æ’åºä¸Šåˆ‡æ¢çš„æ•ˆç‡æ›´é«˜çš„**æ’å…¥æ’åº**ï¼Œæˆ–è€…ä½¿ç”¨**ä¸‰å‘åˆ‡åˆ†**ï¼ˆç”¨å­æ•°ç»„ä¸€éƒ¨åˆ†å…ƒç´ çš„ä¸­ä½æ•°ä½œä¸ºåˆ‡åˆ†å…ƒç´ ï¼‰çš„æ–¹æ³•ï¼Œè¿™äº›è®¨è®ºåŒæ ·å‚è§ä¹‹å‰æåˆ°çš„èµ„æ–™[^1]ã€‚
:::

### å †æ’åº

+ å°†æ•°ç»„æ„é€ æˆä¸€ä¸ª**æœ€å¤§å †**æˆ–è€…**æœ€å°å †**ã€‚
+ ä¾æ¬¡å°†å †é¡¶å…ƒç´ popå‡ºæ¥ï¼Œæ”¾åˆ°æ•°ç»„çš„æœ«å°¾(æˆ–å¼€å¤´)ï¼Œè¿™æ ·æ•°ç»„å°±å˜æˆäº†æœ‰åºçš„ã€‚

ç”±äºå †æˆ–è€…ä¼˜å…ˆçº§é˜Ÿåˆ—çš„æœ¬è´¨æ˜¯ä¸€ç§æ•°æ®ç»“æ„è€Œéæ’åºç®—æ³•ï¼Œæœ¬æ–‡ä¸èµ˜è¿°å®ƒçš„å…·ä½“å®ç°ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œåªéœ€è¦çŸ¥é“å †é¡¶å…ƒç´ ä¸€å®šæ˜¯æœ€å€¼å…ƒç´ å³å¯ã€‚å †æ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸º$O(nlog(n))$ï¼Œä½†æ˜¯ç”±äºå †çš„å®ç°éœ€è¦é¢å¤–çš„ç©ºé—´å¼€é”€ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º$O(n)$ã€‚

```go
func sort(nums []int) {
    pq := make(PriorityQueue, len(nums))
    heap.Init(&pq)
    for _, num := range nums {
        heap.Push(&pq, num)
    }
    i := 0
    for heap.Len(&pq) > 0 {
        nums[i] = heap.Pop(&pq).(int)
        i++
    }
}

// Golangå®ç°å †çš„boilerplateä»£ç ï¼Œç¡®å®å¾ˆç¹çğŸ˜¡ï¼Œå°¤å…¶æ˜¯å½“æˆ‘ä»¬åªéœ€è¦å¤„ç†ç®€å•çš„æ•°æ®ç»“æ„çš„æ—¶å€™

type PriorityQueue []int

func (pq PriorityQueue) Len() int {
    return len(pq)
}

func (pq PriorityQueue) Less(i, j int) bool {
    return pq[i] > pq[j]
}

func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
}

func (pq *PriorityQueue) Push(x interface{}) {
    *pq = append(*pq, x.(int))
}

func (pq *PriorityQueue) Pop() interface{} {
    n := len(*pq)
    x := (*pq)[n-1]
    *pq = (*pq)[:n-1]
    return x
}
```

## Golang çš„ sort åŒ…

> [Package sort](https://pkg.go.dev/sort) provides primitives for sorting slices and user-defined collections.

### åŸºæœ¬ä½¿ç”¨

å¯¹äºåŸºæœ¬æ•°æ®ç±»å‹åˆ‡ç‰‡ï¼Œ`sort`å†…ç½®3ç±»å¸¸è§æ•°æ®ç±»å‹åˆ‡ç‰‡çš„æ’åºå‡½æ•°ï¼š

+ `sort.Ints`ï¼šå¯¹`int`åˆ‡ç‰‡è¿›è¡Œæ’åºã€‚
+ `sort.Float64s`ï¼šå¯¹`float64`åˆ‡ç‰‡è¿›è¡Œæ’åºã€‚
+ `sort.Strings`ï¼šå¯¹`string`åˆ‡ç‰‡è¿›è¡Œæ’åºã€‚

äº‹å®ä¸Šï¼Œ`sort`é¢„å…ˆå®šä¹‰äº†ç”¨äºæ’åºçš„`Interface`æ¥å£ï¼Œåªè¦å®ç°äº†è¿™ä¸ªæ¥å£ï¼Œå°±å¯ä»¥ä½¿ç”¨`sort.Sort`å‡½æ•°è¿›è¡Œæ’åºã€‚è€Œé’ˆå¯¹ä¸Šè¿°3ç§åŸºæœ¬æ•°æ®ç±»å‹ï¼Œ`sort`åŒ…å·²ç»å®ç°äº†å¯¹åº”çš„`Interface`æ¥å£ï¼šIntSliceã€Float64Sliceã€StringSliceï¼Œåœ¨å¯¹åº”çš„æ’åºå‡½æ•°ä¸­å®é™…ä¸Šè¿›è¡Œäº†ç±»å‹è½¬æ¢ã€‚

```go
// ç±»ä¼¼äºå‰é¢å †æ’åºä¸­çš„PriorityQueueï¼Œè¿™é‡Œçš„Interfaceè¦æ±‚å®ç°Lenã€Lessã€Swapä¸‰ä¸ªæ–¹æ³•ä»¥ä¾¿æ’åº
type Interface interface {
        Len() int
        // å¦‚æœéœ€è¦é™åºæ’åºï¼Œå¯ä»¥å°†Lessçš„è¿”å›å€¼å–åï¼Œå³å†™Greaterçš„é€»è¾‘
        Less(i, j int) bool
        Swap(i, j int)
}

// ä¸‹é¢ä»£ç ä»¥IntSliceä¸ºä¾‹ï¼Œå…¶ä»–ç±»å‹çš„å®ç°ç±»ä¼¼
func Ints(x []int) { Sort(IntSlice(x)) }

type IntSlice []int
// Interfaceæ¥å£å®ç°
func (x IntSlice) Len() int           { return len(x) }
func (x IntSlice) Less(i, j int) bool { return x[i] < x[j] }
func (x IntSlice) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }

func (x IntSlice) Sort() { Sort(x) }

// ä¹Ÿå¯ä»¥è‡ªå®šä¹‰æ•°æ®ç±»å‹ï¼Œå®ç°Interfaceæ¥å£ï¼Œä½¿ç”¨sort.Sortè¿›è¡Œæ’åº
func Sort(data Interface) {
	n := data.Len()
	if n <= 1 {
		return
	}
	limit := bits.Len(uint(n))
	pdqsort(data, 0, n, limit)
}
```

### What's inside this `pdqsort` function?

Golang å®é™…ä¸Šåœ¨è¯¥å‡½æ•°ä¸­é‡‡ç”¨äº†ä¸€å®šçš„**å…·ä½“æ’åºç®—æ³•çš„é€‰æ‹©ç­–ç•¥**ï¼Œæ ¹æ®å…·ä½“çš„å…ƒç´ å¹³è¡¡æƒ…å†µå’Œåˆ‡ç‰‡é•¿åº¦ï¼Œåˆ†åˆ«åœ¨ä¸åŒçš„å±‚çº§é‡‡ç”¨å¿«æ’ã€æ’å…¥æ’åºå’Œå †æ’åºï¼Œå…·ä½“çš„æ³¨é‡Šå¯å‚è§ä¸‹é¢`sort`åŒ…æºç çš„ä»£ç å—ï¼š

```go
// pdqsort sorts data[a:b].
// The algorithm based on pattern-defeating quicksort(pdqsort), but without the optimizations from BlockQuicksort.
// pdqsort paper: https://arxiv.org/pdf/2106.05123.pdf
// C++ implementation: https://github.com/orlp/pdqsort
// Rust implementation: https://docs.rs/pdqsort/latest/pdqsort/
// limit is the number of allowed bad (very unbalanced) pivots before falling back to heapsort.
func pdqsort(data Interface, a, b, limit int) {
	const maxInsertion = 12

	var (
		wasBalanced    = true // whether the last partitioning was reasonably balanced
		wasPartitioned = true // whether the slice was already partitioned
	)

	for {
		length := b - a

		if length <= maxInsertion {
            // å½“åˆ‡ç‰‡é•¿åº¦å°äºç­‰äº12æ—¶ï¼Œä½¿ç”¨æ’å…¥æ’åºï¼Œå¦‚å‰é¢è®¨è®ºï¼Œåˆ‡ç‰‡é•¿åº¦è¾ƒå°æ—¶ï¼Œæ’å…¥æ’åºçš„æ€§èƒ½è¾ƒå¥½
			insertionSort(data, a, b)
			return
		}

		// Fall back to heapsort if too many bad choices were made.
		if limit == 0 {
            // å¦‚æœåˆ‡ç‰‡é•¿åº¦è¾ƒå¤§ï¼Œä¸”ä¸å¹³è¡¡çš„åˆ‡åˆ†è¿‡å¤šï¼Œåˆ™ç›´æ¥ä½¿ç”¨å †æ’åº
			heapSort(data, a, b)
			return
		}

		// If the last partitioning was imbalanced, we need to breaking patterns.
		if !wasBalanced {
			breakPatterns(data, a, b)
			limit--
		}

        // ä»¥ä¸‹å¯ä»¥ç†è§£ä¸ºå¿«æ’
		pivot, hint := choosePivot(data, a, b)
		if hint == decreasingHint {
			reverseRange(data, a, b)
			// The chosen pivot was pivot-a elements after the start of the array.
			// After reversing it is pivot-a elements before the end of the array.
			// The idea came from Rust's implementation.
			pivot = (b - 1) - (pivot - a)
			hint = increasingHint
		}

		// The slice is likely already sorted.
		if wasBalanced && wasPartitioned && hint == increasingHint {
			if partialInsertionSort(data, a, b) {
				return
			}
		}

		// Probably the slice contains many duplicate elements, partition the slice into
		// elements equal to and elements greater than the pivot.
		if a > 0 && !data.Less(a-1, pivot) {
			mid := partitionEqual(data, a, b, pivot)
			a = mid
			continue
		}

		mid, alreadyPartitioned := partition(data, a, b, pivot)
		wasPartitioned = alreadyPartitioned

		leftLen, rightLen := mid-a, b-mid
		balanceThreshold := length / 8
		if leftLen < rightLen {
			wasBalanced = leftLen >= balanceThreshold
			pdqsort(data, a, mid, limit)
			a = mid + 1
		} else {
			wasBalanced = rightLen >= balanceThreshold
			pdqsort(data, mid+1, b, limit)
			b = mid
		}
	}
}
```

## CPP STL algorithm sort()

> [std::sort](https://en.cppreference.com/w/cpp/algorithm/sort) is a sorting algorithm that sorts the elements in the range [first, last) in non-descending order. The order of equal elements is not guaranteed to be preserved.

åŒGolangï¼Œåœ¨é»˜è®¤æƒ…å†µä¸‹ï¼ŒCPPä½¿ç”¨`< operator`ï¼Œå³lesserè¿›è¡Œæ’åºã€‚

ä»¥ä¸‹æ˜¯SGI STLä¸­çš„sortå‡½æ•°å®ç°ã€‚

```cpp
template <class _RandomAccessIter>
inline void sort(_RandomAccessIter __first, _RandomAccessIter __last) {
    __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
    __STL_REQUIRES(typename iterator_traits<_RandomAccessIter>::value_type,
                    _LessThanComparable);
    if (__first != __last) {
        // å½“å®¹å™¨é•¿åº¦å¤§äº16æ—¶ï¼Œä½¿ç”¨introsortï¼Œintrosortæœ¬èº«ç±»ä¼¼äºä¸‰åˆ†ä½å¿«æ’
        __introsort_loop(__first, __last,
                        __VALUE_TYPE(__first),
                        __lg(__last - __first) * 2);
        // æœ€åä½¿ç”¨æ’å…¥æ’åºå®Œæˆå°æ•°ç»„çš„æ’åº
        __final_insertion_sort(__first, __last);
    }
}

template <class _Size>
inline _Size __lg(_Size __n) {
    // è®¡ç®—log2(__n)çš„å€¼ï¼Œå³2çš„å¤šå°‘æ¬¡æ–¹ç­‰äº__nï¼Œ __kå°†ç”¨ä½œintrosortçš„é€’å½’æ·±åº¦
    _Size __k;
    for (__k = 0; __n != 1; __n >>= 1) ++__k;
    return __k;
}

template <class _RandomAccessIter, class _Tp, class _Size>
void __introsort_loop(_RandomAccessIter __first,
                        _RandomAccessIter __last, _Tp*,
                        _Size __depth_limit)
{
    // __stl_threshold = 16 ç±»ä¼¼äºGolangçš„maxInsertion
    // __depth_limitå³é€’å½’æ·±åº¦ï¼Œç±»ä¼¼äºGolangçš„limit
    while (__last - __first > __stl_threshold) {
        if (__depth_limit == 0) {
            // partial_sortç”¨å †æ’åºå®ç°
            partial_sort(__first, __last, __last);
            return;
        }
        --__depth_limit;
        // __medianæ±‚å–é¦–ã€å°¾ã€ä¸­ä½æ•°ä¸‰è€…çš„ä¸­ä½æ•°
        _RandomAccessIter __cut =
          __unguarded_partition(__first, __last,
                                _Tp(__median(*__first,
                                             *(__first + (__last - __first)/2),
                                             *(__last - 1))));
        __introsort_loop(__cut, __last, (_Tp*) 0, __depth_limit);
        __last = __cut;
    }
}

template <class _RandomAccessIter, class _Tp>
_RandomAccessIter __unguarded_partition(_RandomAccessIter __first, 
                                        _RandomAccessIter __last, 
                                        _Tp __pivot) 
{
    // ç±»ä¼¼äºå¿«æ’çš„partition
    while (true) {
        while (*__first < __pivot)
            ++__first;
        --__last;
        while (__pivot < *__last)
            --__last;
        if (!(__first < __last))
            return __first;
        iter_swap(__first, __last);
        ++__first;
    }
}
```